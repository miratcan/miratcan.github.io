<!DOCTYPE html>
<html>
<head>
  <style type="text/css">

    body {
      max-width: 40em;
      margin: 4em auto;
    }

    pre {
      font-family: inherit;
      color: inherit;
      background: #ccc;
      border: 1px solid #000;
      padding: 1em;
      overflow: auto;
    }

    ul.nav {
      list-style-type: none;
      overflow: auto;
      padding: 0;
    }

    ul.nav li {
      float: left;
      margin: 0 20px 0 0;
    }

    img {
      max-width: 100%;
    }
    li {
      margin-bottom: 0.25em;
    }
    span.date {
      font-size: 0.7em;
      float: right;
    }
    table {
      width: 100%;
    }
    th, td {
      border-bottom: 1px solid black;
      padding: 0.25em;
      text-align: left;
    }
    img {
      left: 0;
      right: 0;
      margin-right: auto;
      margin-left: auto;
    }   

  </style>
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Django&#39;da tehlikeli template etiketi: length. — Mirat Can Bayrak</title>
</head>
<body>
<ul class="nav">
  <li>
    <a href="../../">Anasayfa</a></li>
    
      <li class="active">
        <a href="../../blog/">Blog</a>
      </li>
    
      <li>
        <a href="../../projeler/">Projeler</a>
      </li>
    
</ul>

  
  <h1>Django&#39;da tehlikeli template etiketi: length.</h1>
  <p>Bugün yeni projeyle uğraşırken template içinde bir noktanın baya yavaş render edildiğini hissettim. (Bu arada Markafoni'den ayrıldım onu bilhare anlatırım.) Template içerisinde bir QuerySet length template filtresiyle çağırılıyordu:</p>
<pre><code>{% if BlaBla.all|length == 5 %}
    ..
{% endif %}
</code></pre>
<p>length template filtresini açıp baktığımda verilen değeri len fonksiyonuna geçirdiğini <a href="https://github.com/django/django/blob/master/django/template/defaultfilters.py#L577">gördüm</a>:</p>
<pre><code>@register.filter(is_safe=False)
def length(value):
    """Returns the length of the value - useful for lists."""
    try:
        return len(value)
    except (ValueError, TypeError):
        return 0
</code></pre>
<p>İşte tam da arıza burada başlıyor. Len fonksiyonu ile bir QuerySet'in uzunluğunu almaya çalıştığınızda QuerySet'in tamamını veritabanından alıp, bir listeye dönüştürüp ardından listenin uzunluğunu alıyor. Bu da devasa tablolarda hem memory sıkıntısı, hem de veritabanı sunucularını gereksiz meşgul etmek demek. Sqldebugshell ile len metodunun nasıl bir sorgu çalıştırdığına baktığımda manzara şu şekilde:</p>
<pre><code>In [6]: len(BlaBla.objects.all())

SELECT `c..`.`id`,
       `c..`.`i..`,
       `c..`.`p..`,
       `c..`.`c..`,
       `c..`.`s..`,
       `c..`.`i..`,
       `c..`.`i..`,
       `c..`.`u..`,
       `c..`.`u..`,
       `c..`.`s..`,
       `c..`.`c..`,
       `channel_customstream`.`t..`
FROM `channel_customstream`
</code></pre>
<p>Görüldüğü üzere o modele ait her şeyi toplayarak alan bir sorgu oluşturdu. Halbuki count metodu QuerySet'lerin direkt olarak veritabanında Count çalıştırması sağlanabiliyor:</p>
<pre><code>In [5]: CustomStream.objects.count()

SELECT COUNT(*)
FROM `channel_customstream` 
</code></pre>
<p>Diyeceğim o ki, length etiketini count sorgusu yaptığını sanarak kullanmayınız.</p>

  <hr />
  <p>Mirat - January 2014</p>

</body>
</html>


